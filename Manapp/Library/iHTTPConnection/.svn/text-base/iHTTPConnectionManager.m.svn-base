//
//  iHTTPConnectionManager.m
//  iCore for iOS
//
//  Created by Quan Dang Dinh on 8/27/10.
//  Copyright Â© 2012 Lumos Technology Ltd.,. All rights reserved.
//

#import "iHTTPConnectionManager.h"
#import "iHTTPConnectionManagerDelegate.h"
#import "iURLConnection.h"
#import "iUtilities.h"
#import "SBJSON.h"

@interface iHTTPConnectionManager (Private)

- (NSMutableData *)getDataForConnection:(iURLConnection *)connection;

- (NSMutableData *)getDataByTag:(NSString *)tag;

- (void)removeConnectionFromListByTag:(NSString *)tag;

- (id<iHTTPConnectionManagerDelegate>)getDelegateByTag:(NSString *)tag;

- (id<iHTTPConnectionManagerDelegate>)getDelegateForConnection:(iURLConnection *)connection;

@end

@implementation iHTTPConnectionManager

#pragma mark Constructors
- (id)init{
    self = [super init];
	if (self) {
		if (_listReceivedData == nil) {
			_listReceivedData = [[NSMutableDictionary alloc] init];
		}
		if (_listDelegate == nil) {
			_listDelegate = [[NSMutableDictionary alloc] init];
		}
		if (_listUrlConnection == nil) {
			_listUrlConnection = [[NSMutableDictionary alloc] init];
		}
	}
	
	return self;
}

#pragma mark Private Functions
- (NSMutableData *)getDataForConnection:(iURLConnection *)connection{
	return [self getDataByTag:connection.Tag];
}

- (NSMutableData *)getDataByTag:(NSString *)tag{
	return [_listReceivedData objectForKey:tag];
}

- (id<iHTTPConnectionManagerDelegate>)getDelegateByTag:(NSString *)tag{
	return [_listDelegate objectForKey:tag];
}

- (id<iHTTPConnectionManagerDelegate>)getDelegateForConnection:(iURLConnection *)connection{
	return [self getDelegateByTag:connection.Tag];
}

- (iURLConnection *)getConnectionByTag:(NSString *)tag{
	return [_listUrlConnection objectForKey:tag];
}

- (void)removeConnectionFromListByTag:(NSString *)tag{
	// Remove URLConnection, Delegate, ReceivedData from the list by tag
	[_listReceivedData removeObjectForKey:tag];
	[_listDelegate removeObjectForKey:tag];
	[_listUrlConnection removeObjectForKey:tag];
}

#pragma mark NSURLConnection delegate handlers
- (void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response {
	NSMutableData *dataForConnection = [self getDataForConnection:(iURLConnection*)connection];
	[dataForConnection setLength:0];
}

- (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data {
	NSMutableData *dataForConnection = [self getDataForConnection:(iURLConnection*)connection];
	[dataForConnection appendData:data];
}

- (void)connectionDidFinishLoading:(NSURLConnection *)connection {
	iURLConnection *__currentConnection = (iURLConnection *)connection;
	NSMutableData *__receivedData = [self getDataForConnection:__currentConnection];
	id<iHTTPConnectionManagerDelegate> __currentDelegate = [self getDelegateForConnection:__currentConnection];
	
	if (__currentDelegate && [__currentDelegate respondsToSelector:@selector(finishedDownloadWithTag:downloadedData:)]) {
		[__currentDelegate finishedDownloadWithTag:__currentConnection.Tag downloadedData:__receivedData];
		
		[self removeConnectionFromListByTag:__currentConnection.Tag];
	}
}

- (void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error{
	iURLConnection *__currentConnection = (iURLConnection *)connection;
	id<iHTTPConnectionManagerDelegate> __currentDelegate = [self getDelegateForConnection:__currentConnection];
	
	if (__currentDelegate && [__currentDelegate respondsToSelector:@selector(errorDownloadWithTag:error:)]) {
		[__currentDelegate errorDownloadWithTag:__currentConnection.Tag error:error];
		
		[self removeConnectionFromListByTag:__currentConnection.Tag];
	}
}

#pragma mark Custom delegate handlers
- (void)downloadDataFromURL:(NSString *)url withTag:(NSString *)tag delegate:(id<iHTTPConnectionManagerDelegate>)delegate{
	NSURLRequest *__newRequest = [[NSURLRequest alloc] initWithURL:[NSURL URLWithString:url]];
	iURLConnection *__newConnection = [[iURLConnection alloc] initWithRequest:__newRequest delegate:self startImmediately:YES tag:tag];

	if (__newConnection) {
		[_listReceivedData setObject:[NSMutableData data] forKey:tag];
		[_listDelegate setObject:delegate forKey:tag];
		[_listUrlConnection setObject:__newConnection forKey:tag];
		
		if (delegate && [delegate respondsToSelector:@selector(startedDownloadWithTag:)]) {
			[delegate startedDownloadWithTag:tag];
		}
	}
	
	[__newConnection release]; __newConnection = nil;
	[__newRequest release]; __newRequest = nil;
}

- (NSString *)downloadDataFromURL:(NSString *)url delegate:(id<iHTTPConnectionManagerDelegate>)delegate{
    NSString *__autoGeneratedTag = [iUtilities generateGUID];
    
    [self downloadDataFromURL:url withTag:__autoGeneratedTag delegate:delegate];
    
    return __autoGeneratedTag;
}

- (void)downloadDataFromURL:(NSString *)url withTag:(NSString *)tag cacheAllowance:(BOOL)cacheAllowance cacheTimeout:(int)cacheTimeout delegate:(id<iHTTPConnectionManagerDelegate>)delegate{
	NSURLRequest *__newRequest;
	if (cacheAllowance) {
		__newRequest = [[NSURLRequest alloc] initWithURL:[NSURL URLWithString:url] cachePolicy:NSURLRequestReturnCacheDataElseLoad timeoutInterval:cacheTimeout];
	}
	else {
		__newRequest = [[NSURLRequest alloc] initWithURL:[NSURL URLWithString:url]];
	}

	iURLConnection *__newConnection = [[iURLConnection alloc] initWithRequest:__newRequest delegate:self startImmediately:YES tag:tag];
	
	if (__newConnection) {
		[_listReceivedData setObject:[NSMutableData data] forKey:tag];
		[_listDelegate setObject:delegate forKey:tag];
		[_listUrlConnection setObject:__newConnection forKey:tag];
		
		if (delegate && [delegate respondsToSelector:@selector(startedDownloadWithTag:)]) {
			[delegate startedDownloadWithTag:tag];
		}
	}
	
	[__newConnection release]; __newConnection = nil;
	[__newRequest release]; __newRequest = nil;
}

- (void)postData:(NSString *)data toURL:(NSString *)url withTag:(NSString *)tag delegate:(id <iHTTPConnectionManagerDelegate>)delegate{
	NSMutableURLRequest *__newRequest = [[NSMutableURLRequest alloc] initWithURL:[NSURL URLWithString:url]];
	NSData *__requestData = [data dataUsingEncoding:NSUTF8StringEncoding allowLossyConversion:YES];
	
	[__newRequest setValue:@"application/x-www-form-urlencoded" forHTTPHeaderField:@"Content-Type"];
	[__newRequest setValue:[@"" stringByAppendingFormat:@"%d", [data length]] forHTTPHeaderField:@"Content-Length"];
	[__newRequest setHTTPMethod:@"POST"];
	[__newRequest setHTTPBody:__requestData];	
	iURLConnection *__newConnection = [[iURLConnection alloc] initWithRequest:__newRequest delegate:self startImmediately:YES tag:tag];
	
	if (__newConnection) {
		[_listReceivedData setObject:[NSMutableData data] forKey:tag];
		[_listDelegate setObject:delegate forKey:tag];
		[_listUrlConnection setObject:__newConnection forKey:tag];
		
		if (delegate && [delegate respondsToSelector:@selector(startedDownloadWithTag:)]) {
			[delegate startedDownloadWithTag:tag];
		}
	}
	
	[__newConnection release]; __newConnection = nil;
	[__newRequest release]; __newRequest = nil;
}

- (void)downloadDataWithConnection:(iURLConnection *)connection delegate:(id<iHTTPConnectionManagerDelegate>)delegate{
	if (connection) {
		[_listReceivedData setObject:[NSMutableData data] forKey:connection.Tag];
		[_listDelegate setObject:delegate forKey:connection.Tag];
		[_listUrlConnection setObject:connection forKey:connection.Tag];
		
		if (delegate && [delegate respondsToSelector:@selector(startedDownloadWithTag:)]) {
			[delegate startedDownloadWithTag:connection.Tag];
		}
	}
}

- (void)cancelDownloadWithTag:(NSString *)tag{
	iURLConnection *__connectionToBeCanceled = [self getConnectionByTag:tag];
	[__connectionToBeCanceled cancel];
	id<iHTTPConnectionManagerDelegate> __delegateToBeNotified = [self getDelegateByTag:tag];
	if (__delegateToBeNotified && [__delegateToBeNotified respondsToSelector:@selector(canceledDownloadWithTag:)]) {
		[__delegateToBeNotified canceledDownloadWithTag:tag];
	}
	
	[self removeConnectionFromListByTag:tag];
}

#pragma mark Destructor
- (void)dealloc{
	[_listReceivedData release]; _listReceivedData = nil;
	[_listDelegate release]; _listDelegate = nil;
	[_listUrlConnection release]; _listUrlConnection = nil;
	
	[super dealloc];
}
@end
